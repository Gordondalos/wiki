
var green = function(name){
console.log(arguments[]); // ["Sorax",34,25,26] // это обьект который рабоатет как массив  
return "Привет" + name
}

greet("Sorax",34,25,26);

***************************************
var func = function(){
return function(){
console.log("hi");
}
};

func()(); // вернет hi


************************

это анонимная самовызывающаяся функция применяетя рекурсия для этого нужно дать ей имя

var greeting = (function(name){

return "hello" + name;

}("sorax"));


console.log("greeting"); // вернет hello sorax;
************************************************************************




обьявлять переменные всегда в начале функции


Замыкания

берем функцию (№1) в ней делаем другую функцию(№2) которая хранит в себе переменную и возвращает ее.

если из третьей функции(№3) вызвать вторую функцию напримсер так func()();
то ее значчение переменной хранимой во второй функции будет применено и использовано, если нет второй функции в первой
то мусорщик затрет значение переменной после ее вычесления и ее значение в третьей функции получить будет невозможно


например так сделаны счетичики
тут реализованана анонимная самовызывающаяся функция

var counter = (function(){
var count = 0;
return function(){
return count++;
}
}());

colnsole.log(counter()); // вернет 0

colnsole.log(counter()); // уже вернет 1 и так далее

прелесть замыканий в том что как у нас тут они могут ничего не принимать но возвращают разные значения
и дают возможность сохранять какието данные и это позволяет инкапсуляцию данных

а также во вторую функцию - вложенную можно передать переменную например чтобы сбросить счетчик
или задать новый уровень исчеслений, нужно проверить на андефайн


тоже самое можно получить дургим способом так как функция может вести себя как обьект

var counter = function(num){
counter.count = num !== undefinded ? num : counter.count;
return counter.count++;

};

counter.count = 0;

colnsole.log(counter()); // вернет 0

colnsole.log(counter()); // уже вернет 1 и так далее












